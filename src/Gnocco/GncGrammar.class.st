"
I am a generative (context-free) grammar. Inspect me!
"
Class {
	#name : #GncGrammar,
	#superclass : #Object,
	#traits : 'TFuzzAst',
	#classTraits : 'TFuzzAst classTrait',
	#instVars : [
		'parameters',
		'start'
	],
	#category : #'Gnocco-Grammar'
}

{ #category : #initialization }
GncGrammar >> computeCost [

	| again |
	again := false.
	{
		GncMinHeightComputer new.
		GncMinSizeComputer new } do: [ :visitor |
		self start visit: visitor.
		again := again | visitor changed ].
	^ again
]

{ #category : #initialization }
GncGrammar >> defineGrammar [

	self subclassResponsibility
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminal: body [

	self eachNonTerminalSlot: [ :slot |
		| nonTerminal |
		nonTerminal := slot read: self.
		body value: nonTerminal ]
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminalSlot: body [

	self class allSlots do: [ :slot |
		(slot name beginsWith: 'nt') ifTrue: [
			body value: slot ] ]
]

{ #category : #translating }
GncGrammar >> generateAst: generator [

	^ self start generateAst:
		  (generator
			   offsetHeightCost: self minHeight
			   andSizeCost: self minSize)
]

{ #category : #translating }
GncGrammar >> generateWithMinCost [

	^ self generate: (GncGrammarGenerator newMinimal)
]

{ #category : #initialization }
GncGrammar >> initialize [

	self eachNonTerminalSlot: [ :slot |
		| name nonTerminal |
		name := slot name allButFirst: 2.
		nonTerminal := GncNonTerminal withName: name.
		slot write: nonTerminal to: self ].

	start := self defineGrammar.
	"Now, we must compute the minimum cost of expanding a non terminal, and the minimum cost of"
	"expanding a non terminal with a certain rule. The cost constraints can be expressed with"
	"the following, mutually recursive set of equations:"
	" cost(T) = 1+min(max(cost(T_i) for i in [1, n]) for T -> T_1, ..., T_n)"
	"   where T spans over all non terminals, and T -> T_1, ..., T_n over all production rules"
	" cost(a) = 0   where a spans over all terminals"
	"To compute a solution to this system of equations, we note that its solutions are the"
	"fixpoints of a monotone operator over the complete lattice of A^k, where A is
	the set of natural numbers with the addition of the infinity, ordered with the
	opposite natural order. By the Knaster-Tarski theorem, we can iterate the
	operator. Since A^k has no infinite chain, this will converge in a finite number
	of steps."
	[ self computeCost ] whileTrue.

	parameters := GncParameterCollectionVisitor new
		              visitOn: self start;
		              parameters.

	self start minHeight isFinite ifFalse: [ "The language generated by this grammar is empty"
		GrammarIsNotProductive new signal: 'The grammar is non-productive' ].

	self eachNonTerminal: [ :nonTerminal |
		nonTerminal rules size isZero ifTrue: [
			UndefinedNonTerminal new signal: 'You forgot to define ' , nonTerminal name ] ].

	"I'm not sure whether this is useful, but there it is."
	self eachNonTerminal: [ :nonTerminal | nonTerminal seal ].
	self start
]

{ #category : #accessing }
GncGrammar >> minHeight [

	^ self start minHeight
]

{ #category : #accessing }
GncGrammar >> minSize [

	^ self start minSize
]

{ #category : #initialization }
GncGrammar >> parameters [

	^ parameters
]

{ #category : #printing }
GncGrammar >> printOn: stream [

	self eachNonTerminal: [ :nonTerminal |
		self start = nonTerminal ifTrue: [ stream << '@' ].
		stream
			print: nonTerminal;
			<< OSPlatform current lineEnding ]
]

{ #category : #translating }
GncGrammar >> showInInspect [

	<inspectorPresentationOrder: 0 title: 'Grammar Rules'>
	^ SpTextPresenter new
		  text: self printString;
		  beNotEditable;
		  yourself
]

{ #category : #initialization }
GncGrammar >> start [

	^ start
]
