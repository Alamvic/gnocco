"
I am a generative (context-free) grammar. Inspect me!
"
Class {
	#name : #GncGrammar,
	#superclass : #Object,
	#traits : 'TFuzzAst',
	#classTraits : 'TFuzzAst classTrait',
	#instVars : [
		'parameters'
	],
	#category : #'Gnocco-Grammar'
}

{ #category : #initialization }
GncGrammar >> computeCost [

	self start visit: GncMinHeightComputer new.
	self start visit: GncMinSizeComputer new
]

{ #category : #initialization }
GncGrammar >> defineGrammar [

	self subclassResponsibility
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminal: body [

	self eachNonTerminalSlot: [ :slot |
		| nonTerminal |
		nonTerminal := slot read: self.
		body value: nonTerminal ]
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminalSlot: body [

	self class allSlots do: [ :slot |
		(slot name beginsWith: 'nt') ifTrue: [
			body value: slot ] ]
]

{ #category : #translating }
GncGrammar >> generateAst: generator [

	^ self start generateAst: (generator offsetHeightCost: self minHeight)
]

{ #category : #translating }
GncGrammar >> generateWithMinCost [

	^ self generate: (GncGenerator new)
]

{ #category : #initialization }
GncGrammar >> initialize [

	self eachNonTerminalSlot: [ :slot |
		| name nonTerminal |
		name := slot name allButFirst: 2.
		nonTerminal := GncNonTerminal withName: name.
		slot write: nonTerminal to: self ].

	self defineGrammar.
	"Now, we must compute the minimum cost of expanding a non terminal, and the minimum cost of"
	"expanding a non terminal with a certain rule. The cost constraints can be expressed with"
	"the following, mutually recursive set of equations:"
	" cost(T) = 1+min(max(cost(T_i) for i in [1, n]) for T -> T_1, ..., T_n)"
	"   where T spans over all non terminals, and T -> T_1, ..., T_n over all production rules"
	" cost(a) = 0   where a spans over all terminals"
	"To compute a solution to this system of equations, we note that its solutions are the"
	"fixpoints of a monotone operator, [stuff]Â¸ so we iterate the operator until we find"
	"a fixpoint."
	"However, in this case, because we are looking for the minimum cost, we can actually iterate"
	"only twice! This is because, in the first iteration, we will already find all the correct"
	"costs for the terminals and non terminals, because the minimum cost will not happen in a"
	"derivation that involves expanding the same non terminal twice in a path from the root of"
	"the derivation tree."
	"This means that we only need a second step, to compute the cost of the *rules*."
	self computeCost.
	self computeCost.

	parameters := GncParameterCollectionVisitor new
		              visitOn: self start;
		              parameters.

	self start minHeight isFinite ifFalse: [ "The language generated by this grammar is empty"
		Error new signal: 'This grammar is non-productive' ].

	self eachNonTerminal: [ :nonTerminal |
		nonTerminal rules size isZero ifTrue: [
			Error new signal: 'You forgot to define ' , nonTerminal name ] ].

	"I'm not sure whether this is useful, but there it is."
	self eachNonTerminal: [ :nonTerminal | nonTerminal seal ].
	self start
]

{ #category : #accessing }
GncGrammar >> minHeight [

	^ self start minHeight
]

{ #category : #initialization }
GncGrammar >> parameters [

	^ parameters
]

{ #category : #printing }
GncGrammar >> printOn: stream [

	self eachNonTerminal: [ :nonTerminal |
		self start = nonTerminal ifTrue: [ stream << '@' ].
		stream
			print: nonTerminal;
			<< OSPlatform current lineEnding ]
]

{ #category : #translating }
GncGrammar >> showInInspect [

	<inspectorPresentationOrder: 0 title: 'Grammar Rules'>
	^ SpTextPresenter new
		  text: self printString;
		  beNotEditable;
		  yourself
]

{ #category : #accessing }
GncGrammar >> start [

	self subclassResponsibility
]
