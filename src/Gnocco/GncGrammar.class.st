"
I am a generative (context-free) grammar. Inspect me!
"
Class {
	#name : #GncGrammar,
	#superclass : #Object,
	#traits : 'TFuzzAst',
	#classTraits : 'TFuzzAst classTrait',
	#category : #'Gnocco-Grammar'
}

{ #category : #accessing }
GncGrammar >> cost [

	^ self start cost
]

{ #category : #initialization }
GncGrammar >> defineGrammar [
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminal: body [

	self eachNonTerminalSlot: [ :slot |
		| nonTerminal |
		nonTerminal := slot read: self.
		body value: nonTerminal ]
]

{ #category : #'iterating elements' }
GncGrammar >> eachNonTerminalSlot: body [

	self class allSlots do: [ :slot |
		(slot name beginsWith: 'nt') ifTrue: [
			body value: slot ] ]
]

{ #category : #printing }
GncGrammar >> format: stream [

	self eachNonTerminal: [ :nonTerminal |
		self start = nonTerminal ifTrue: [ stream << '@' ].
		nonTerminal format: stream.
		stream << OSPlatform current lineEnding ]
]

{ #category : #translating }
GncGrammar >> generateAstWithMaxCost: cost [

	^ self start generateAstWithMaxCost: cost
]

{ #category : #translating }
GncGrammar >> generateWithMinCost [

	^ self generateWithMaxCost: self cost
]

{ #category : #initialization }
GncGrammar >> initialize [

	self eachNonTerminalSlot: [ :slot |
		| name nonTerminal |
		name := slot name allButFirst: 2.
		nonTerminal := GncNonTerminal withName: name.
		slot write: nonTerminal to: self ].

	self defineGrammar.
	"Now, we must compute the minimum cost of expanding a non terminal, and the minimum cost of"
	"expanding a non terminal with a certain rule. The cost constraints can be expressed with"
	"the following, mutually recursive set of equations:"
	" cost(T) = 1+min(max(cost(T_i) for i in [1, n]) for T -> T_1, ..., T_n)"
	"   where T spans over all non terminals, and T -> T_1, ..., T_n over all production rules"
	" cost(a) = 0   where a spans over all terminals"
	"To compute a solution to this system of equations, we note that its solutions are the"
	"fixpoints of a monotone operator, [stuff]Â¸ so we iterate the operator until we find"
	"a fixpoint."
	"However, in this case, because we are looking for the minimum cost, we can actually iterate"
	"only twice! This is because, in the first iteration, we will already find all the correct"
	"costs for the terminals and non terminals, because the minimum cost will not happen in a"
	"derivation that involves expanding the same non terminal twice in a path from the root of"
	"the derivation tree."
	"This means that we only need a second step, to compute the cost of the *rules*."
	self start computeCost.
	self start reset. "visited nodes are marked with a flag, so we reset the flag"
	self start computeCost.

	self start cost isFinite ifFalse: [ "The language generated by this grammar is empty"
		Error new signal: 'This grammar is non-productive' ].

	self eachNonTerminal: [ :nonTerminal |
		nonTerminal rules size isZero ifTrue: [
			Error new signal: 'You forgot to define ' , nonTerminal name ] ].

	"I'm not sure whether this is useful, but there it is."
	self eachNonTerminal: [ :nonTerminal | nonTerminal seal ]
]

{ #category : #printing }
GncGrammar >> printString [

	^ String streamContents: [ :stream | self format: stream ]
]

{ #category : #translating }
GncGrammar >> showInInspect [

	<inspectorPresentationOrder: 0 title: 'Grammar Rules'>
	^ SpTextPresenter new
		  text: self printString;
		  beNotEditable;
		  yourself
]

{ #category : #accessing }
GncGrammar >> start [

	self subclassResponsibility
]
